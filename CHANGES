v0.5.2 (2006/07/18)
* The receipt of messages is now threadsafe. Previously,
  TIdSipMessageWait objects held references to TIdSipTransports. Now,
  they hold a copy of the message and a Transport ID (a String), which
  the TIdSipMessageWait uses to find the appropriate Transport. It
  does this by consulting a well-known registry -
  TIdSipTransportRegistry - which now not only tracks what types of
  transports you may use, but also stores references to all created
  TIdSipTransports. (The addition and deletion of these references is
  all accomplished in TIdSipTransport.Create and Destroy.)
* The Transaction-User and Transaction layers now use asynchronous
  algorithms to send messages.
* The stack now supports hairpinned requests.
* In the test infrastructure, you no longer have to specify A/AAAA
  records for hosts used in tests. You can if you want, setting the
  TIdSipMockLocator's ReturnOnlySpecifiedRecords to true.
* A major reshuffling of Transport classes: all TCP classes are now in
  IdSipTcpTransport.pas, UDP classes in IdSipUdpTransport.pas, and so
  on, and common classes remain in IdSipTransport. That means that
  units like IdSipTcpClient.pas have been deleted.
* All appropriate call flow classes (those for INVITE, REGISTER,
  SUBSCRIBE, REFER) now support redirection.
* Removed TIdSDPPayloadProcessor: use TIdSDPMultimediaSession.
* Bugfixes:
** RTP sessions send control data to themselves.
** RTCP packets sent from RTP port.
** RTP stack attempts to send media to port 0.
** Creating a StackInterface without a "Supports:" line causes an
   Invalid Cast exception.
** OnNetworkFailure causes access violation/dangling pointer
** Outbound dialogs incorrectly set remote sequence number to local
   sequence number.

v0.5.1 (2006/01/31)
* The stack now supports basic multihoming: having more than one
  non-local IP on the machine running the UA. This code has not been
  widely tested, so may fail! However, "single-homed" machines will
  still run as normal.
* Missing copyright boilerplate added.
* TIdSipActionRedirector encapsulates the logic around issuing
  multiple requests in response to redirection responses. Currently
  only TIdSipOutboundSession uses the logic, but we hope to have
  TIdSipOutboundRegistration, TIdSipOutboundSubscription and
  TIdSipOutboundReferral using the logic too.

v0.5 (2006/01/15)
* Completed GRUU (draft-ietf-sip-gruu-06) support (except for
  proxy-related sections).
* Added the MasqueradeAs directive to the stack configuration,
  allowing a UA to pretend to be another machine (usually a NATting
  firewall) by rewriting certain headers.
* Bugfixes: we now properly handle terminating a session when we've
  accepted the INVITE but attempted to terminate the session before we
  received the remote party's ACK: we wait for the ACK and then
  immediately send a BYE

v0.5pre (2006/01/03)
* The SIP stack now supports subscriptions (RFC 3265), including the
  REFER message (RFC 3515). This means that the stack implements call
  forwarding as per draft-ietf-sipping-cc-transfer-05. Note that some
  aspects of call transfer are purely UI issues (choosing blind versus
  attended transfer, for instance). The stack leaves those sorts of
  questions to the UI. (See RFC 3515 section 2.4.2 for a typical
  UI-only issue.)
* The stack now handles authentication challenges in an asynchronous
  manner. That means that the program that uses the stack now uses
  Action.Resend() to resend an authorised request.
* Major reshuffling of code in the Transaction-User layer: most of 
  IdSipCore now sits in IdSipRegistration and IdSipUserAgent.

v0.4.1 (2005/05/20)
* Added those files necessary to patch Indy to support the stack.

v0.4 (2005/05/19)
* Major architectural changes: The SIP stack now executes in the
  context of one thread, a TIdThreadedTimerQueue: a
  TIdSipStackInterface. Any actions you request the stack to take
  result in TIdWait objects being added to the TimerQueue's list, and
  it will execute those actions when it gets a chance. Communication
  from the stack to your code happens via Windows' PostMessage. When
  you instantiate the StackInterface you give it the handle to a
  window that will handle the requests. You are responsible for
  destroying any objects you receive from the stack!
* We now use DNS to locate SIP entities. Since Indy 9 only supports
  IPv4 addresses, the stack doesn't support handling AAAA records even
  though it doesn't care how addresses look: all layers treat
  addresses as strings, and only the transport layer knows or cares
  that those addresses match a particular format.
* The stack now passes the 3xx STFT tests.
* The Spike.pas unit used a hardcoded username/password, which of
  course made the torture tests fail.
* Authentication's changed a lot: the Transaction layer (i.e., the
  TransactionDispatcher) resends challenged requests, but the
  Transaction-User layer (i.e., the AbstractUserAgent) supplies the
  authentication credentials. Thus, a Transaction receives a 401
  response, the TransactionDispatcher notifies its listeners, the
  UserAgent (which always listens) notifies the user, asking for a
  username/password for the response. The user specifies if they want
  to re-issue the request, and if they do, the TransactionDispatcher
  creates a new client transaction with the credentials. This
  (currently) completely empties the ActionListener interface.
* TIdMethod renamed to TIdNotification.
* The (Abstract) UserAgent now farms out events (things that you
  schedule in a TimerQueue) to separate objects, rather than using
  TNotifyEvents. In fact, anything involving its Actions property now
  works exclusively off blocks/closures sent to the Actions.
* Lots of niggly race conditions in the tests have been fixed.

v0.3 (2004/12/24)

* Transaction User Actions look like Commands (see the Gang of Four's
  Design Patterns book).
* Transaction User objects (i.e., Actions) and Transactions no longer
  use their own threads for timing events - they use their
  UserAgentCore or Dispatcher to schedule events.
* "Message Modules": If you want a Core to handle call messages
  (INVITE, ACK, BYE, CANCEL), you just call
  Core.AddModule(TIdSipInviteModule). If you want it to also handle
  REGISTER messages, just call
  Core.AddModule(TIdSipRegisterModule). OPTIONS?
  Core.AddModule(TIdSipOptionsModule). In general, if you want a Core
  to handle some message (say, INFO or REFER or MESSAGE or whatever),
  subclass TIdSipMessageModule and create an Outbound and Inbound
  Action for the Module. Use the InviteModule, RegisterModule and
  OptionsModule classes as examples. INVITEs behave differently to
  other messages, so the Register- and OptionsModules will likely help
  you the most.
* All threads now subclass TIdBaseThread, which subclasses TThread and
  not TIdThread.
* Dispatcher now creates transactions for CANCELs.
* You can terminate sessions both before you receive a 200 OK and
  after. In the former case you send a CANCEL & the latter a BYE. We
  check that the CANCEL did actually cancel and, if not, send a
  BYE. (This can happen when the far end accepts the call before your
  CANCEL reaches it.)
* Sessions can now process redirect messages and try the received
  alternate Contacts. We could use a better algorithm here!
* You can now modify sessions. As per RFC 3261 section 14.1, we also
  handle "glare" situations (simultaneous re-INVITEs by two parties in
  the session).
* General system-wide refactorings:
** Sessions now use InviteActions and no longer know about the details
   of receiving/sending INVITEs.
** Actions and Transactions no longer ask their Core/Dispatcher to
   free them. Instead, they mark themselves as Terminated, and the
   Core/Dispatcher removes all terminated Actions/Transactions at
   appropriate times (like after sending/receiving messages).

v0.2 (2004/09/20)

* Parsing SIP messages doesn't raise exceptions. Instead, the messages
  and headers store the original, unparsed, data and you check their
  HasValidSyntax property to find out if the message/header contains
  valid data.
* The SipMessage and SipHeader objects now parse themselves - the
  SipParser now provides helper utilities and such.
* This allows us to simplify the servers drastically - TCP and UDP
  servers do nothing but parse messages and hand them up to the
  Transport object.
* Notification of events now uses the NotificationList. This contains
  a bunch of Interfaces, and you give it a Method (a reified method
  call) which the NotificationList then executes on each of its
  Interfaces. This eliminates a whole bunch of almost-identical
  code.
* The Transaction layer now understands how to process CANCELs as well
  as send them. For Client INVITE transactions only, of course.
* SDP Payload Processor never really worked nicely. We thus replace it
  (keeping it around for the nonce for reference purposes) with
  RTPMediaStreams and company. This implements (most of) RFC 3264, the
  Offer/Answer model.
* Encapsulated the essentials of TIdSocketHandle (local and remote
  addresses and ports) so that high-level objects don't know about
  TIdSocketHandle. This helps to minimise dependencies on the core
  Indy classes, hopefully allowing enterprising programmers to port
  the stack more easily to, say, FreePascal.
* Some threads now wait for TEvents rather than polling to do their
  thing. Much neater.